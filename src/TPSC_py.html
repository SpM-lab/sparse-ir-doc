
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>TPSC approximation &#8212; sparse-ir</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Eliashberg theory for Holstein-Hubbard model" href="eliashberg_holstein_py.html" />
    <link rel="prev" title="FLEX approximation" href="FLEX_py.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-RD8N0K0C9Y"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-RD8N0K0C9Y');
                </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">sparse-ir</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basic theory
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="IR_py.html">
   Intermediate representation (IR)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sparse_sampling_py.html">
   Sparse sampling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DLR.html">
   Discrete Lehmann representation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="api.html">
   API reference
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="additional_material.html">
   Additional material
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Sample codes
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="transformation_py.html">
   Transformation from/to IR
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sparse_sampling_demo_py.html">
   Sparse sampling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DLR_py.html">
   Discrete Lehmann Representation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="second_order_perturbation_py.html">
   Second-order perturbation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="GW_py.html">
   The GF2 &amp; GW method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DMFT_IPT_py.html">
   DMFT with IPT solver
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="FLEX_py.html">
   FLEX approximation
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   TPSC approximation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eliashberg_holstein_py.html">
   Eliashberg theory for Holstein-Hubbard model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="orbital_magnetic_susceptibility_py.html">
   Orbital magnetic susceptibility
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="liechtenstein_py.html">
   Estimation of exchange interactions
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Analytic continuation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="analytic_continuation_py.html">
   Numerical analytic continuation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="spm_py.html">
   SpM analytic continuation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Sample codes (Julia)
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="transformation_jl.html">
   Transformation from/to IR
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DLR_jl.html">
   Discrete Lehmann Representation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DMFT_IPT_jl.html">
   DMFT calculation with IPT
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="FLEX_jl.html">
   FLEX approximation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="BgG_jl.html">
   Bogoliubov-de Gennes equations in real space
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Sample codes (Fortran)
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="second_order_perturbation_fort.html">
   Second-order perturbation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="citation.html">
   Citation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bibliography.html">
   Bibliograpy
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/src/TPSC_py.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#theory-of-tpsc">
   Theory of TPSC
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#set-of-tpsc-equations">
     Set of TPSC equations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#notes-on-practical-implementation">
     Notes on practical implementation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#code-implementation">
   Code implementation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parameter-setting">
     Parameter setting
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generating-meshes">
     Generating meshes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#tpsc-solver">
     TPSC solver
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#execute-tpsc-solver">
     Execute TPSC solver
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#visualize-results">
       Visualize results
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-interaction-dependent-renormalization">
   Example: Interaction dependent renormalization
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>TPSC approximation</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#theory-of-tpsc">
   Theory of TPSC
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#set-of-tpsc-equations">
     Set of TPSC equations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#notes-on-practical-implementation">
     Notes on practical implementation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#code-implementation">
   Code implementation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parameter-setting">
     Parameter setting
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generating-meshes">
     Generating meshes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#tpsc-solver">
     TPSC solver
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#execute-tpsc-solver">
     Execute TPSC solver
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#visualize-results">
       Visualize results
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-interaction-dependent-renormalization">
   Example: Interaction dependent renormalization
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="tpsc-approximation">
<h1>TPSC approximation<a class="headerlink" href="#tpsc-approximation" title="Permalink to this headline">#</a></h1>
<p>Author: <a class="reference external" href="mailto:niklas&#46;witt&#37;&#52;&#48;physik&#46;uni-hamburg&#46;de">Niklas Witt</a></p>
<section id="theory-of-tpsc">
<h2>Theory of TPSC<a class="headerlink" href="#theory-of-tpsc" title="Permalink to this headline">#</a></h2>
<p>The Two-Particle Self-Consistent (TPSC) approximation is a non-perturbative semi-analytical method that was first introduced by Vilk and Tremblay <span id="id1">[<a class="reference internal" href="bibliography.html#id46" title="Y. M. Vilk and A.-M. S. Tremblay. Non-Perturbative Many-Body Approach to the Hubbard Model and Single-Particle Pseudogap. Journal de Physique I, 7(11):1309–1368, nov 1997. arXiv:cond-mat/9702188, doi:10.1051/jp1:1997135.">Vilk and Tremblay, 1997</a>]</span>. TPSC can be used to study magnetic fluctuations, while it also obeys the Mermin-Wagner theorem, i.e., a phase transtition at finite temperatures is prohibited in one or two dimensions. In addition, the TPSC method satisfies several conservation laws, sum rules and the Pauli principle (actually, it is constructed in a way to fulfill these, since they are used to determine model parameters self-consistently). TPSC is applicable in the weak to intermediate coupling regime, but it breaks down in the strong coupling regime and it cannot describe the Mott transition unlike other non-perturbative methods like Dynamical Mean-Field Theory (DMFT).</p>
<p>For a (pedagogical) review, please have a look at <span id="id2">[<a class="reference internal" href="bibliography.html#id48" title="S. Allen, A.-M. S. Tremblay, and Y. M. Vilk. Conserving Approximations vs. Two-Particle Self-Consistent Approach, chapter 8. Springer-Verlag New York, 2004. arXiv:cond-mat/0110130.">Allen <em>et al.</em>, 2004</a>, <a class="reference internal" href="bibliography.html#id47" title="André-Marie S. Tremblay. Two-Particle-Self-Consistent Approach for the Hubbard Model, pages 409–453. Springer Berlin Heidelberg, Berlin, Heidelberg, 2012. URL: https://doi.org/10.1007/978-3-642-21831-6_13, arXiv:1107.1534, doi:10.1007/978-3-642-21831-6_13.">Tremblay, 2012</a>]</span> for the single-orbital case implemented here and <span id="id3">[<a class="reference internal" href="bibliography.html#id49" title="Karim Zantout, Steffen Backes, and Roser Valentí. Two-particle self-consistent method for the multi-orbital hubbard model. Annalen der Physik, 533(2):2000399, 2021. URL: https://onlinelibrary.wiley.com/doi/abs/10.1002/andp.202000399, arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/andp.202000399, doi:https://doi.org/10.1002/andp.202000399.">Zantout <em>et al.</em>, 2021</a>]</span> for the more complex multi-orbital theory.</p>
<section id="set-of-tpsc-equations">
<h3>Set of TPSC equations<a class="headerlink" href="#set-of-tpsc-equations" title="Permalink to this headline">#</a></h3>
<p>We review the set of equations that need to be solved in the TPSC approximation assuming a one-band Hubbard model with interaction <span class="math notranslate nohighlight">\(U\)</span> (it is not so easy to extend TPSC to models with more parameters, since sum rules to determine the additional parameters self-consistently need to be found) in the paramagnetic phase (SU(2) symmetric), i.e., <span class="math notranslate nohighlight">\(n = \langle n\rangle = 2n_{\sigma}\)</span> for the electron filling <span class="math notranslate nohighlight">\(n\)</span>. TPSC is constructed in a way to fulfill certain sum rules and the Pauli principle in the form <span class="math notranslate nohighlight">\(\langle n^2\rangle = \langle n\rangle\)</span>. The control quantitites are spin and charge correlation function (susceptibilities) which are evaluated in a Random-Phase-Approximation (RPA) like fashion</p>
<div class="math notranslate nohighlight">
\[ \chi_{\mathrm{sp}}^{\mathrm{RPA}}(i\nu_m, \boldsymbol{q}) = \frac{\chi_0(i\nu_m, \boldsymbol{q})}{1-U\chi_0(i\nu_m, \boldsymbol{q})}\;,\quad \chi_{\mathrm{ch}}^{\mathrm{RPA}}(i\nu_m, \boldsymbol{q}) = \frac{\chi_0(i\nu_m, \boldsymbol{q})}{1+U\chi_0(i\nu_m, \boldsymbol{q})} \]</div>
<p>with the irreducible susceptibility (“bubble diagram”)</p>
<div class="math notranslate nohighlight">
\[ \chi_0(i\nu_m, \boldsymbol{q}) = - \frac{T}{N_{\boldsymbol{k}}} \sum_{n,\boldsymbol{k}} G(i\omega_n + i\nu_m, \boldsymbol{k} + \boldsymbol{q})G(i\omega_n, \boldsymbol{k})\;,\]</div>
<p>where <span class="math notranslate nohighlight">\(\nu_m = 2n\pi T\)</span> [<span class="math notranslate nohighlight">\(\omega_n=(2n+1)\pi T\)</span>] and <span class="math notranslate nohighlight">\(\boldsymbol{q}\)</span> [<span class="math notranslate nohighlight">\(\boldsymbol{k}\)</span>] are bosonic [fermionic] Matsubara frequencies and momentum at temperature <span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(N_{\boldsymbol{k}}\)</span> denotes the number of <span class="math notranslate nohighlight">\(\boldsymbol{k}\)</span>-points, and <span class="math notranslate nohighlight">\(G_0(i\omega_n,\boldsymbol{k}) = [i\omega_n - (\varepsilon_{\boldsymbol{k}}-\mu)]^{-1}\)</span> is the bare (non-interacting) Green function with with single-particle dispersion <span class="math notranslate nohighlight">\(\varepsilon_{\boldsymbol{k}}\)</span> and chemical potential <span class="math notranslate nohighlight">\(\mu\)</span>. Please note that sometimes a factor of 2 is included in the definition of <span class="math notranslate nohighlight">\(\chi_0\)</span> leading to slightly different factors in all equations given here. The convolution sum to calculate <span class="math notranslate nohighlight">\(\chi_0\)</span> can be easily evaluated by Fourier transforming to imaginary-time and real space, resulting in a simple multiplication</p>
<div class="math notranslate nohighlight">
\[ \chi_0(\tau, \boldsymbol{r}) = - G(\tau, \boldsymbol{r})G(-\tau,-\boldsymbol{r}) = G(\tau, \boldsymbol{r})G(\beta-\tau,\boldsymbol{r})\;.\]</div>
<p>In our practical implementation, we will perform this step using the <code class="docutils literal notranslate"><span class="pre">sparse-ir</span></code> package. A similar calculation is necessary to set the chemical potential <span class="math notranslate nohighlight">\(\mu\)</span> for fixed electron density <span class="math notranslate nohighlight">\(n\)</span>, as the equation</p>
<div class="math notranslate nohighlight">
\[ n = 2n_{\sigma} = 2 + \frac{2}{N_{\boldsymbol{k}}} \sum_{\boldsymbol{k}} G(\tau=0^+, \boldsymbol{k}) \]</div>
<p>(factor 2 from spin degeneracy and <span class="math notranslate nohighlight">\(0^+ = \lim_{\eta\to 0+} \eta\)</span>) needs to be solved by using some root finding algorithm like bisection method or Brent’s method. The Fourier transformation to <span class="math notranslate nohighlight">\(\tau=0^+\)</span> can be easily performed with the <code class="docutils literal notranslate"><span class="pre">sparse-ir</span></code> package.</p>
<p>The above RPA definition of spin and charge susceptibility violate the Pauli principle. In TPSC, we overcome this problem by introducing two effective, renormalized interactions (“irreducible vertices”) <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}\)</span> and <span class="math notranslate nohighlight">\(U_{\mathrm{ch}}\)</span> that enter spin and charge correlation functions as</p>
<div class="math notranslate nohighlight">
\[ \chi_{\mathrm{sp}}(i\nu_m, \boldsymbol{q}) = \frac{\chi_0(i\nu_m, \boldsymbol{q})}{1-U_{\mathrm{sp}}\chi_0(i\nu_m, \boldsymbol{q})}\;,\quad \chi_{\mathrm{ch}}(i\nu_m, \boldsymbol{q}) = \frac{\chi_0(i\nu_m, \boldsymbol{q})}{1+U_{\mathrm{ch}}\chi_0(i\nu_m, \boldsymbol{q})}\,. \]</div>
<p>These two effetive interactions are determined by the two local sum rules</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
    2 \frac{T}{N_{\boldsymbol{k}}} \sum_{m,\boldsymbol{q}} \chi_{\mathrm{sp}} &amp;= \left\langle (n_{\uparrow} - n_{\downarrow})^2\right\rangle = n - 2\langle n_{\uparrow}n_{\downarrow}\rangle\;,\\
    2 \frac{T}{N_{\boldsymbol{k}}} \sum_{m,\boldsymbol{q}} \chi_{\mathrm{ch}} &amp;= \left\langle (n_{\uparrow} + n_{\downarrow})^2\right\rangle - \left\langle n_{\uparrow} + n_{\downarrow}\right\rangle^2 =  n + 2\langle n_{\uparrow}n_{\downarrow}\rangle - n^2\;.
\end{align}
\end{split}\]</div>
<p>Both sum rules can be exactly derived from the Pauli principle (<span class="math notranslate nohighlight">\(\langle n^2\rangle = \langle n\rangle\)</span>). In principle, we can now determine <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}\)</span> and <span class="math notranslate nohighlight">\(U_{\mathrm{ch}}\)</span> from local-spin and local-charge sum rule if we knew the double occupancy <span class="math notranslate nohighlight">\(\langle n_{\uparrow}n_{\downarrow}\rangle\)</span>. TPSC makes the ansatz</p>
<div class="math notranslate nohighlight">
\[ U_{\mathrm{sp}}\langle n_{\uparrow}\rangle\langle n_{\downarrow}\rangle = U_{\mathrm{sp}}\frac{n^2}{4} = U\langle n_{\uparrow}n_{\downarrow}\rangle\;,\]</div>
<p>which reproduces Kanamori-Brueckner type screening. The four equations above form a set of self-consistent equations for either <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}\)</span> or equivalently <span class="math notranslate nohighlight">\(\langle n_{\uparrow}n_{\downarrow}\rangle\)</span>. In practice, we treat <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}\)</span> as the parameter to be determined self-consistently by inserting the ansatz in the local-spin sum rule. Effectively, we then need to find the root of the function</p>
<div class="math notranslate nohighlight">
\[ f(U_{\mathrm{sp}}) = 2\frac{T}{N_{\boldsymbol{k}}} \sum_{m,\boldsymbol{q}}\chi_{\mathrm{sp}}(U_{\mathrm{sp}}) - n + \frac{U_{\mathrm{sp}}}{2U}n^2\;. \]</div>
<p>Afterwards we can calculate the double occupancy <span class="math notranslate nohighlight">\(\langle n_{\uparrow}n_{\downarrow}\rangle = \frac{U_{\mathrm{sp}}}{4U} n^2\)</span> and then perform a similar root finding for <span class="math notranslate nohighlight">\(U_{\mathrm{ch}}\)</span> from the function</p>
<div class="math notranslate nohighlight">
\[ g(U_{\mathrm{ch}}) = 2 \frac{T}{N_{\boldsymbol{k}}} \sum_{m,\boldsymbol{q}} \chi_{\mathrm{ch}}(U_{\mathrm{ch}}) - n - 2\langle n_{\uparrow}n_{\downarrow}\rangle^2 + n^2\;. \]</div>
<p>In TPSC, a self-energy <span class="math notranslate nohighlight">\(\Sigma\)</span> can be derived that is calculated from the interaction <span id="id4">[<a class="reference internal" href="bibliography.html#id50" title="S. Moukouri, S. Allen, F. Lemay, B. Kyung, D. Poulin, Y. M. Vilk, and A.-M. S. Tremblay. Many-body theory versus simulations for the pseudogap in the hubbard model. Phys. Rev. B, 61:7887–7892, Mar 2000. URL: https://link.aps.org/doi/10.1103/PhysRevB.61.7887, doi:10.1103/PhysRevB.61.7887.">Moukouri <em>et al.</em>, 2000</a>]</span></p>
<div class="math notranslate nohighlight">
\[ V(i\nu_m, \boldsymbol{q}) = \frac{U}{4} \left(3 U_{\mathrm{sp}} \chi_{\mathrm{sp}}(i\nu_m, \boldsymbol{q}) + U_{\mathrm{ch}} \chi_{\mathrm{ch}}(i\nu_m, \boldsymbol{q})\right) + U\;. \]</div>
<p>The self-energy itself is given by a convolution in <span class="math notranslate nohighlight">\((i\omega_n, \boldsymbol{k})\)</span> space</p>
<div class="math notranslate nohighlight">
\[ \Sigma(i\omega_n, \boldsymbol{k}) = \frac{T}{N_{\boldsymbol{k}}} \sum_{m,\boldsymbol{q}} V(i\nu_m, \boldsymbol{q}) G(i\omega_n - i\nu_m, \boldsymbol{k} - \boldsymbol{q}) \]</div>
<p>which Fourier transformed to <span class="math notranslate nohighlight">\((\tau,\boldsymbol{r})\)</span> space takes the form</p>
<div class="math notranslate nohighlight">
\[ \Sigma(\tau, \boldsymbol{r}) = V(\tau, \boldsymbol{r}) G(\tau, \boldsymbol{r})\;. \]</div>
<p>The interacting Green function is determined by the Dyson equation</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
G(i\omega_n,\boldsymbol{k}) &amp;= [G_0^{-1}(i\omega_n,\boldsymbol{k}) - \Sigma(i\omega_n,\boldsymbol{k})]^{-1} \\
&amp; = [i\omega_n - (\varepsilon_{\boldsymbol{k}}-\mu) - \Sigma(i\omega_n,\boldsymbol{k})]^{-1}.
\end{align}
\end{split}\]</div>
</section>
<section id="notes-on-practical-implementation">
<h3>Notes on practical implementation<a class="headerlink" href="#notes-on-practical-implementation" title="Permalink to this headline">#</a></h3>
<p>When implementing the TPSC, a few points need to be treated carefully which we adress in the following:</p>
<ul class="simple">
<li><p>The constant Hartree term <span class="math notranslate nohighlight">\(V_{\mathrm{H}} = U\)</span> in the interaction <span class="math notranslate nohighlight">\(V\)</span> and respective self-energy term <span class="math notranslate nohighlight">\(\Sigma_H = U n_{\sigma} = U\frac{n}{2}\)</span> can be absorbed into the definition of the chemical potential <span class="math notranslate nohighlight">\(\mu\)</span>. Otherwise we would have to treat this term separately, since the IR basis cannot model the <span class="math notranslate nohighlight">\(\delta\)</span>-peak in frequency space well/compactly. In this case, evaluate the term analytically and add it after the Fourier transformation step.</p></li>
<li><p>An upper bound for the renormalized spin vertex <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}\)</span> exists. Since the denominator spin susceptibility <span class="math notranslate nohighlight">\(\chi_{\mathrm{sp}}\)</span> should not diverge, the upper bound is given by the RPA critical interaction value <span class="math notranslate nohighlight">\(U_{\mathrm{crit}} = 1/\mathrm{max}\{\chi^0\}\)</span>. Mathematically, the function <span class="math notranslate nohighlight">\(f(U_{\mathrm{sp}}) = 2\sum \chi_{\mathrm{sp}}(U_{\mathrm{sp}}) - n + \frac{U_{\mathrm{sp}}}{2U}n^2\)</span>, from which <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}\)</span> is determined, turns unstable for <span class="math notranslate nohighlight">\(U_{\mathrm{sp}} \geq U_{\mathrm{crit}}\)</span> (try plotting <span class="math notranslate nohighlight">\(f(U_{\mathrm{sp}})\)</span>!). At this point, TPSC is not applicable and, e.g., the temperature <span class="math notranslate nohighlight">\(T\)</span> is too low or the (unrenormalized) interaction <span class="math notranslate nohighlight">\(U\)</span> too large.</p></li>
<li><p>An internal accuracy check <span class="math notranslate nohighlight">\(\frac{1}{2}\mathrm{Tr}(\Sigma G) = U \langle n_{\uparrow} n_{\downarrow}\rangle\)</span> can be employed to test the validity of TPSC (not done here).</p></li>
</ul>
</section>
</section>
<section id="code-implementation">
<h2>Code implementation<a class="headerlink" href="#code-implementation" title="Permalink to this headline">#</a></h2>
<p>We are implementing TPSC for the simple case of a square lattice model with dispersion <span class="math notranslate nohighlight">\(\varepsilon_{\boldsymbol{k}} = -2t\,[\cos(k_x) + \cos(k_y)]\)</span> with nearest-neighbor hopping <span class="math notranslate nohighlight">\(t\)</span> which sets the energy scale of our system (bandwidth <span class="math notranslate nohighlight">\(W = 8t\)</span>). First, we load all necessary basic modules that we are going to need in implementing TPSC and visualizing results:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import numpy as np
import scipy as sc
import scipy.optimize
from warnings import warn
import sparse_ir
%matplotlib inline
import matplotlib.pyplot as plt
</pre></div>
</div>
</div>
</div>
<section id="parameter-setting">
<h3>Parameter setting<a class="headerlink" href="#parameter-setting" title="Permalink to this headline">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>### System parameters
t    = 1      # hopping amplitude
W    = 8*t    # bandwidth
wmax = 10     # set wmax &gt;= W

T    = 0.1    # temperature
beta = 1/T    # inverse temperature
n    = 0.85   # electron filling, here per spin per lattice site (n=1: half filling)
U    = 4      # Hubbard interaction

### Numerical parameters
nk1, nk2  = 24, 24    # number of k_points along one repiprocal crystal lattice direction k1 = kx, k2 = ky
nk        = nk1*nk2
IR_tol    = 1e-10     # desired accuary for l-cutoff of IR basis functions
</pre></div>
</div>
</div>
</div>
</section>
<section id="generating-meshes">
<h3>Generating meshes<a class="headerlink" href="#generating-meshes" title="Permalink to this headline">#</a></h3>
<p>We need to generate a <span class="math notranslate nohighlight">\(\boldsymbol{k}\)</span>-mesh as well as set up the IR basis functions on a sparse <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(i\omega_n\)</span> grid. Then we can calculate the dispersion on this mesh.
In addition, we set calculation routines to Fourier transform <span class="math notranslate nohighlight">\(k\leftrightarrow r\)</span> and <span class="math notranslate nohighlight">\(\tau\leftrightarrow i\omega_n\)</span> (via IR basis).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#### Initiate fermionic and bosonic IR basis objects
IR_basis_set = sparse_ir.FiniteTempBasisSet(beta, wmax, eps=IR_tol)

class Mesh:
    &quot;&quot;&quot;
    Holding class for k-mesh and sparsely sampled imaginary time &#39;tau&#39; / Matsubara frequency &#39;iwn&#39; grids.
    Additionally it defines the Fourier transform routines &#39;r &lt;-&gt; k&#39;  and &#39;tau &lt;-&gt; l &lt;-&gt; wn&#39;.
    &quot;&quot;&quot;
    def __init__(self,IR_basis_set,nk1,nk2):
        self.IR_basis_set = IR_basis_set

        # generate k-mesh and dispersion
        self.nk1, self.nk2, self.nk = nk1, nk2, nk1*nk2
        self.k1, self.k2 = np.meshgrid(np.arange(self.nk1)/self.nk1, np.arange(self.nk2)/self.nk2)
        self.ek = -2*t*( np.cos(2*np.pi*self.k1) + np.cos(2*np.pi*self.k2) ).reshape(nk)

        # lowest Matsubara frequency index
        self.iw0_f = np.where(self.IR_basis_set.wn_f == 1)[0][0]
        self.iw0_b = np.where(self.IR_basis_set.wn_b == 0)[0][0]

        ### Generate a frequency-momentum grid for iw_n and ek (in preparation for calculating the Green function)
        # frequency mesh (for Green function)
        self.iwn_f = 1j * self.IR_basis_set.wn_f * np.pi * T
        self.iwn_f_ = np.tensordot(self.iwn_f, np.ones(nk), axes=0)

        # ek mesh
        self.ek_ = np.tensordot(np.ones(len(self.iwn_f)), self.ek, axes=0)

    def smpl_obj(self, statistics):
        &quot;&quot;&quot; Return sampling object for given statistic &quot;&quot;&quot;
        smpl_tau = {&#39;F&#39;: self.IR_basis_set.smpl_tau_f, &#39;B&#39;: self.IR_basis_set.smpl_tau_b}[statistics]
        smpl_wn  = {&#39;F&#39;: self.IR_basis_set.smpl_wn_f,  &#39;B&#39;: self.IR_basis_set.smpl_wn_b }[statistics]
        return smpl_tau, smpl_wn

    
    def tau_to_wn(self, statistics, obj_tau):
        &quot;&quot;&quot; Fourier transform from tau to iwn via IR basis &quot;&quot;&quot;
        smpl_tau, smpl_wn = self.smpl_obj(statistics)

        obj_tau = obj_tau.reshape((smpl_tau.tau.size, self.nk1, self.nk2))
        obj_l   = smpl_tau.fit(obj_tau, axis=0)
        obj_wn  = smpl_wn.evaluate(obj_l, axis=0).reshape((smpl_wn.wn.size, self.nk))
        return obj_wn

    def wn_to_tau(self, statistics, obj_wn):
        &quot;&quot;&quot; Fourier transform from iwn to tau via IR basis &quot;&quot;&quot;
        smpl_tau, smpl_wn = self.smpl_obj(statistics)

        obj_wn  = obj_wn.reshape((smpl_wn.wn.size, self.nk1, self.nk2))
        obj_l   = smpl_wn.fit(obj_wn, axis=0)
        obj_tau = smpl_tau.evaluate(obj_l, axis=0).reshape((smpl_tau.tau.size, self.nk))
        return obj_tau

    
    def k_to_r(self,obj_k):
        &quot;&quot;&quot; Fourier transform from k-space to real space &quot;&quot;&quot;
        obj_k = obj_k.reshape(-1, self.nk1, self.nk2)
        obj_r = np.fft.fftn(obj_k,axes=(1,2))
        obj_r = obj_r.reshape(-1, self.nk)
        return obj_r

    def r_to_k(self,obj_r):
        &quot;&quot;&quot; Fourier transform from real space to k-space &quot;&quot;&quot;
        obj_r = obj_r.reshape(-1, self.nk1, self.nk2)
        obj_k = np.fft.ifftn(obj_r,axes=(1,2))/self.nk
        obj_k = obj_k.reshape(-1, self.nk)
        return obj_k
</pre></div>
</div>
</div>
</div>
</section>
<section id="tpsc-solver">
<h3>TPSC solver<a class="headerlink" href="#tpsc-solver" title="Permalink to this headline">#</a></h3>
<p>We wrap the calculation steps of TPSC (i.e. determining <span class="math notranslate nohighlight">\(U_{\mathrm{sp}},U_{\mathrm{ch}}\)</span>) in the <code class="docutils literal notranslate"><span class="pre">TPSCSolver</span></code> class. We use the <code class="docutils literal notranslate"><span class="pre">Mesh</span></code> class defined above to perform calculation steps.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class TPSCSolver:
    def __init__(self, mesh, U, n, U_sfc_tol=1e-12, verbose=True):
        &quot;&quot;&quot;
        Solver class to calculate the TPSC method.
        After initializing the Solver by `solver = TPSCSolver(mesh, U, n, **kwargs)` it 
        can be run by `solver.solve()`.
        &quot;&quot;&quot;
        ## set internal parameters for the solver
        self.U = U
        self.n = n
        self.mesh = mesh
        self.U_sfc_tol = U_sfc_tol
        self.verbose = verbose
        
        ## set initial Green function and irreducible susceptibility
        self.sigma = 0
        
        self.mu = 0
        self.mu_calc()
        
        self.gkio_calc(self.mu)
        self.grit_calc()
        self.ckio_calc()
        
        # determine critical U_crit = 1/max(chi0) as an upper bound to U_sp
        self.U_crit = 1/np.amax(self.ckio.real)
    
    
    #%%%%%%%%%%% Solving instance
    def solve(self):
        &quot;&quot;&quot;
        Determine spin and charge vertex self-consistently from sum rules and calculate self-energy.
        &quot;&quot;&quot;
        # determine spin vertex U_sp
        self.spin_vertex_calc()
        
        # set double occupancy from Kanamori-Bruckner screening
        self.docc_calc()
 
        # determine charge vertex U_ch
        self.charge_vertex_calc()
        
        # set spin and charge susceptibility
        self.chi_spin   = self.RPA_term_calc( self.U_sp)
        self.chi_charge = self.RPA_term_calc(-self.U_ch)

        # calculate interaction, self-energy and interacting Green function
        self.V_calc()
        self.sigma_calc()
        self.mu_calc()
        self.gkio_calc(self.mu)
    
    #%%%%%%%%%%% Calculation steps for self.energy
    def gkio_calc(self, mu):
        &quot;&quot;&quot; Calculate Green function G(iw,k) &quot;&quot;&quot;
        self.gkio = (self.mesh.iwn_f_ - (self.mesh.ek_ - mu) - self.sigma)**(-1)

    def grit_calc(self):
        &quot;&quot;&quot; Calculate real space Green function G(tau,r) [for calculating chi0 and sigma] &quot;&quot;&quot;
        # Fourier transform
        grit = self.mesh.k_to_r(self.gkio)
        self.grit = self.mesh.wn_to_tau(&#39;F&#39;, grit)

    def ckio_calc(self):
        &quot;&quot;&quot; Calculate irreducible susciptibility chi0(iv,q) &quot;&quot;&quot;
        ckio = self.grit * self.grit[::-1, :]

        # Fourier transform
        ckio = self.mesh.r_to_k(ckio)
        self.ckio = self.mesh.tau_to_wn(&#39;B&#39;, ckio)

    def V_calc(self):
        &quot;&quot;&quot; Calculate interaction V(tau,r) from RPA-like spin and charge susceptibility &quot;&quot;&quot;
        V = self.U/4 * (3*self.U_sp*self.chi_spin + self.U_ch*self.chi_charge)
        # Constant Hartree Term V ~ U needs to be treated extra, since it cannot be modeled by the IR basis compactly.
        # In the single-band case, the Hartree term can be absorbed into the chemical potential.

        # Fourier transform
        V = self.mesh.k_to_r(V)
        self.V = self.mesh.wn_to_tau(&#39;B&#39;, V)

    def sigma_calc(self):
        &quot;&quot;&quot; Calculate self-energy Sigma(iwn,k) &quot;&quot;&quot;
        sigma = self.V * self.grit
    
        # Fourier transform
        sigma = self.mesh.r_to_k(sigma)
        self.sigma = self.mesh.tau_to_wn(&#39;F&#39;, sigma)


    #%%%%%%%%%%% Determining spin and charge vertex
    def RPA_term_calc(self, U):
        &quot;&quot;&quot; Set RPA-like susceptibility &quot;&quot;&quot;
        chi_RPA = self.ckio / (1 - U*self.ckio)
        return chi_RPA     
    
    def chi_qtrace_calc(self, U):
        &quot;&quot;&quot; Calculate (iv_m, q) trace of chi_RPA term &quot;&quot;&quot;
        # chi_qtrace = sum_(m,q) chi(iv_m,q)
        chi_RPA = self.RPA_term_calc(U)
        chi_trace = np.sum(chi_RPA, axis=1)/self.mesh.nk
        chi_trace_l  = self.mesh.IR_basis_set.smpl_wn_b.fit(chi_trace)
        chi_trace = self.mesh.IR_basis_set.basis_b.u(0)@chi_trace_l
        return chi_trace.real
    
    def docc_calc(self):
        &quot;&quot;&quot; Calculate double occupancy from Kanamori-Bruckner type screening &quot;&quot;&quot;
        self.docc = 0.25 * self.U_sp/self.U * self.n**2
    
    def spin_vertex_calc(self):
        &quot;&quot;&quot; Determine U_sp self-consistently from local sum rule &quot;&quot;&quot;
        # interval [U_a, U_b] for root finding
        U_a = 0
        U_b = np.floor(self.U_crit*100)/100
        
        chi_trace = self.chi_qtrace_calc
        sfc_eq = lambda U_sp : 2*chi_trace(U_sp) - self.n + 0.5*(U_sp/self.U)*self.n**2

        if sfc_eq(U_b) &gt; 0:        
            self.U_sp = sc.optimize.brentq(sfc_eq, U_a, U_b, rtol = self.U_sfc_tol)
        else:
            warn(&quot;System underwent phase transition, U^sp &gt; U_crit = {}! U is too large or T too low for given doping.&quot;.format(self.U_crit))
    
    def charge_vertex_calc(self):
        &quot;&quot;&quot; Determine U_ch self-consistently from local sum rule &quot;&quot;&quot;
        # interval [U_a, U_b] for root finding
        U_a = 0
        U_b = 100
        
        chi_trace = self.chi_qtrace_calc
        sfc_eq = lambda U_ch : 2*chi_trace(-U_ch) - self.n + (1 - 2*self.docc)*self.n**2

        self.U_ch = sc.optimize.brentq(sfc_eq, U_a, U_b, rtol = self.U_sfc_tol)

        
    #%%%%%%%%%%% Setting chemical potential mu
    def calc_electron_density(self, mu):
        &quot;&quot;&quot; Calculate chemical potential mu from Green function &quot;&quot;&quot;
        self.gkio_calc(mu)
        gio  = np.sum(self.gkio,axis=1)/self.mesh.nk
        g_l  = self.mesh.IR_basis_set.smpl_wn_f.fit(gio)
        g_tau0 = self.mesh.IR_basis_set.basis_f.u(0)@g_l
    
        n  = 1 + np.real(g_tau0)
        n  = 2*n #for spin
        return n

    def mu_calc(self):
        &quot;&quot;&quot; Find chemical potential for a given filling n0 via brentq root finding algorithm &quot;&quot;&quot;
        n_calc = self.calc_electron_density
        n0 = self.n
        f  = lambda mu : n_calc(mu) - n0

        self.mu = sc.optimize.brentq(f, np.amax(self.mesh.ek)*3, np.amin(self.mesh.ek)*3)
</pre></div>
</div>
</div>
</div>
</section>
<section id="execute-tpsc-solver">
<h3>Execute TPSC solver<a class="headerlink" href="#execute-tpsc-solver" title="Permalink to this headline">#</a></h3>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># initialize calculation
IR_basis_set = sparse_ir.FiniteTempBasisSet(beta, wmax, eps=IR_tol)
mesh = Mesh(IR_basis_set, nk1, nk2)
solver = TPSCSolver(mesh, U, n)

# perform TPSC calculation
solver.solve()
</pre></div>
</div>
</div>
</div>
<section id="visualize-results">
<h4>Visualize results<a class="headerlink" href="#visualize-results" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot 2D k-dependence of lowest Matsubara frequency of e.g. green function
plt.pcolormesh(2*mesh.k1.reshape(nk1,nk2), 2*mesh.k2.reshape(nk1,nk2), np.real(solver.gkio[mesh.iw0_f].reshape(mesh.nk1,mesh.nk2)), shading=&#39;auto&#39;)
ax = plt.gca()
ax.set_xlabel(&#39;$k_x/\pi$&#39;)
ax.set_xlim([0,2])
ax.set_ylabel(&#39;$k_y/\pi$&#39;)
ax.set_ylim([0,2])
ax.set_aspect(&#39;equal&#39;)
ax.set_title(&#39;Re $G(k,i\omega_0)$&#39;)
plt.colorbar()
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/TPSC_py_12_0.png" src="../_images/TPSC_py_12_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot 2D k-dependence of lowest Matsubara frequency of e.g. self-energy
plt.pcolormesh(2*mesh.k1.reshape(nk1,nk2), 2*mesh.k2.reshape(nk1,nk2), np.imag(solver.sigma[mesh.iw0_f].reshape(mesh.nk1,mesh.nk2)), shading=&#39;auto&#39;)
ax = plt.gca()
ax.set_xlabel(&#39;$k_x/\pi$&#39;)
ax.set_xlim([0,2])
ax.set_ylabel(&#39;$k_y/\pi$&#39;)
ax.set_ylim([0,2])
ax.set_aspect(&#39;equal&#39;)
ax.set_title(&#39;Im $\Sigma(k,i\omega_0)$&#39;)
plt.colorbar()
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/TPSC_py_13_0.png" src="../_images/TPSC_py_13_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot 2D k-dependence of lowest Matsubara frequency of e.g. chi_spin
plt.pcolormesh(2*mesh.k1.reshape(nk1,nk2), 2*mesh.k2.reshape(nk1,nk2), np.real(solver.chi_spin[mesh.iw0_b].reshape(mesh.nk1,mesh.nk2)), shading=&#39;auto&#39;)
ax = plt.gca()
ax.set_xlabel(&#39;$k_x/\pi$&#39;)
ax.set_xlim([0,2])
ax.set_ylabel(&#39;$k_y/\pi$&#39;)
ax.set_ylim([0,2])
ax.set_aspect(&#39;equal&#39;)
ax.set_title(&#39;$\chi_{\mathrm{sp}}(k,i\nu_0)$&#39;)
plt.colorbar()
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/TPSC_py_14_0.png" src="../_images/TPSC_py_14_0.png" />
</div>
</div>
</section>
</section>
</section>
<section id="example-interaction-dependent-renormalization">
<h2>Example: Interaction dependent renormalization<a class="headerlink" href="#example-interaction-dependent-renormalization" title="Permalink to this headline">#</a></h2>
<p>As a simple example demonstration of our <code class="docutils literal notranslate"><span class="pre">sparse-ir</span></code> TPSC code developed above, we will reproduce Fig. 2 of <span id="id5">[<a class="reference internal" href="bibliography.html#id46" title="Y. M. Vilk and A.-M. S. Tremblay. Non-Perturbative Many-Body Approach to the Hubbard Model and Single-Particle Pseudogap. Journal de Physique I, 7(11):1309–1368, nov 1997. arXiv:cond-mat/9702188, doi:10.1051/jp1:1997135.">Vilk and Tremblay, 1997</a>]</span>. It shows the <span class="math notranslate nohighlight">\(U\)</span> dependence of renormalized/effective spin and charge interactions <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}\)</span> and <span class="math notranslate nohighlight">\(U_{\mathrm{ch}}\)</span> (irreducible vertices) at half filling <span class="math notranslate nohighlight">\(n=1\)</span> and <span class="math notranslate nohighlight">\(T&gt;T_{\mathrm{crit}}\)</span> for all considered <span class="math notranslate nohighlight">\(U\)</span> (i.e. <span class="math notranslate nohighlight">\(U_{\mathrm{sp}}&lt;U_{\mathrm{crit}}\)</span> is ensured).</p>
<p>You can simply execute the following two code blocks which will first perform the calculation and then generate a figure like in the reference above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#%%%%%%%%%%%%%%% Parameter settings
print(&#39;Initialization...&#39;)
# system parameters
t = 1         # hopping amplitude
n = 1         # electron filling, here per spin per lattice site (n=1: half filling)
T = 0.4       # temperature
beta =1/T
U_array = np.linspace(1e-10,5,51)  # Hubbard interaction

W    = 8*t    # bandwidth
wmax = 10     # set wmax &gt;= W

# numerical parameters
nk1, nk2  = 24, 24    # k-mesh sufficiently dense!
nk        = nk1*nk2
IR_tol    = 1e-8      # desired accuary for l-cutoff of IR basis functions


# initialize meshes
IR_basis_set = sparse_ir.FiniteTempBasisSet(beta, wmax, eps=IR_tol)
mesh = Mesh(IR_basis_set, nk1, nk2)

# set initial self_energy - will be set to previous calculation step afterwards
sigma_init = 0

# empty arrays for results later
U_sp_array = np.empty((len(U_array)))
U_ch_array = np.empty((len(U_array)))


#%%%%%%%%%%%%%%% Calculations for different U values
print(&quot;Start TPSC loop...&quot;)
for U_it, U in enumerate(U_array):
    #print(&quot;Now: U = {:.1f}&quot;.format(U))
    
    # TPSC solver
    solver = TPSCSolver(mesh, U, n, verbose=False)
    solver.solve()
    
    # save data for plotting
    U_sp_array[U_it] = solver.U_sp
    U_ch_array[U_it] = solver.U_ch
print(&quot;Finished. Plotting now.&quot;)


#%%%%%%%%%%%%%%%% Plot results
plt.plot(U_array, U_ch_array, &#39;-&#39;, label=&#39;$U_{\mathrm{ch}}$&#39;)
plt.plot(U_array, U_sp_array, &#39;-&#39;, label=&#39;$U_{\mathrm{sp}}$&#39;)
ax = plt.gca()
ax.set_xlabel(&#39;$U$&#39;, fontsize=12)
ax.set_xlim([0,5])
ax.set_ylabel(&#39;Interaction&#39;, fontsize=12)
ax.set_ylim([0,20])
ax.legend(frameon=False, fontsize=12)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initialization...
Start TPSC loop...
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Finished. Plotting now.
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fe76a1cc220&gt;
</pre></div>
</div>
<img alt="../_images/TPSC_py_16_3.png" src="../_images/TPSC_py_16_3.png" />
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./src"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="FLEX_py.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">FLEX approximation</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="eliashberg_holstein_py.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Eliashberg theory for Holstein-Hubbard model</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By sparse-ir developers<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>