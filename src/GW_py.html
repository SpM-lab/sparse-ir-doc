
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The GF2 &amp; GW method &#8212; sparse-ir</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="DMFT with IPT solver" href="DMFT_IPT_py.html" />
    <link rel="prev" title="Second-order perturbation" href="second_order_perturbation_py.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-RD8N0K0C9Y"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-RD8N0K0C9Y');
                </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">sparse-ir</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basic theory
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="IR_py.html">
   Intermediate representation (IR)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sparse_sampling_py.html">
   Sparse sampling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DLR.html">
   Discrete Lehmann representation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="api.html">
   API reference
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="additional_material.html">
   Additional material
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Sample codes
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="transformation_py.html">
   Transformation from/to IR
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sparse_sampling_demo_py.html">
   Sparse sampling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DLR_py.html">
   Discrete Lehmann Representation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="second_order_perturbation_py.html">
   Second-order perturbation
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   The GF2 &amp; GW method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DMFT_IPT_py.html">
   DMFT with IPT solver
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="FLEX_py.html">
   FLEX approximation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="TPSC_py.html">
   TPSC approximation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eliashberg_holstein_py.html">
   Eliashberg theory for Holstein-Hubbard model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="orbital_magnetic_susceptibility_py.html">
   Orbital magnetic susceptibility
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="liechtenstein_py.html">
   Estimation of exchange interactions
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Analytic continuation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="analytic_continuation_py.html">
   Numerical analytic continuation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="spm_py.html">
   SpM analytic continuation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Sample codes (Julia)
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="transformation_jl.html">
   Transformation from/to IR
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DLR_jl.html">
   Discrete Lehmann Representation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="DMFT_IPT_jl.html">
   DMFT calculation with IPT
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="FLEX_jl.html">
   FLEX approximation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="BgG_jl.html">
   Bogoliubov-de Gennes equations in real space
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Sample codes (Fortran)
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="second_order_perturbation_fort.html">
   Second-order perturbation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="citation.html">
   Citation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bibliography.html">
   Bibliograpy
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/src/GW_py.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   The GF2 &amp; GW method
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sources">
   Sources
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>The GF2 & GW method</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   The GF2 &amp; GW method
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sources">
   Sources
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import numpy as np
import matplotlib.pyplot as pl
import sparse_ir
import sys 
import math
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>T=0.1
wmax =1

beta = 1/T
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#construction of the Kernel K

#Fermionic Basis

basisf = sparse_ir.FiniteTempBasis(&#39;F&#39;, beta, wmax)

matsf=sparse_ir.MatsubaraSampling(basisf)
tausf=sparse_ir.TauSampling(basisf)

#Bosonic Basis

basisb = sparse_ir.FiniteTempBasis(&#39;B&#39;, beta, wmax)
      
matsb=sparse_ir.MatsubaraSampling(basisb)
tausb=sparse_ir.TauSampling(basisb)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def rho(x):
    return 2/np.pi*np.sqrt(1-(x/wmax)**2)

rho_l=basisf.v.overlap(rho)

G_l_0=-basisf.s*rho_l  


#We compute G_iw two times as we will need G_iw_0 as a constant later on

G_iw_0=matsf.evaluate(G_l_0)
G_iw_f=matsf.evaluate(G_l_0)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#Iterations
i=0

#storage for E_iw to show convergence after iterations
E_iw_f_arr=[]
</pre></div>
</div>
</div>
</div>
<section id="the-gf2-gw-method">
<h1>The GF2 &amp; GW method<a class="headerlink" href="#the-gf2-gw-method" title="Permalink to this headline">#</a></h1>
<p>Above we have successfully derived <span class="math notranslate nohighlight">\(G^F(\bar{\tau}_k^F)\)</span> from <span class="math notranslate nohighlight">\(\hat {G}^F(i\bar{\omega}_n^F)\)</span> by first obtaining the Green’s function’s basis representation <span class="math notranslate nohighlight">\(G_l^F\)</span> and secondly evaluating <span class="math notranslate nohighlight">\(G_l^F\)</span> on the <span class="math notranslate nohighlight">\(\tau\)</span>-sampling points, which are given by the computations of sparse_ir. Here, the self-consistent second order Green’s function theory (GF2) and the self-consistent GW method are are based this very mechanism (and the so called Hedin equations).[5][7]</p>
<p>The following image should give an overview on their iterative schemes[5]:</p>
<br>
<p><img alt="GF2_GW_pic.PNG" src="../_images/GF2_GW_pic.PNG" /></p>
<p>Evaluation and transformation in GW and GF2 is done in the same way (fitting and evaluating) for the quantities <span class="math notranslate nohighlight">\(G,P,W\)</span> and <span class="math notranslate nohighlight">\(\Sigma\)</span>. The transition between these quantities is given by the five Hedin Equations as shown in the panel below (instead of <span class="math notranslate nohighlight">\(P\)</span> the Polarization is denoted with an <span class="math notranslate nohighlight">\(\tilde{\chi}\)</span>).[12] Because the vertex function (between <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(W\)</span>) is approximated as <span class="math notranslate nohighlight">\(\Gamma=1\)</span>, we will only deal with four of them in the GW&amp;GF2 method. By using sparse sampling and the IR basis it is possible to solve these diagrammatic equations efficiently without sustaining a loss in accuracy.[9]
<br>
<img alt="Hedin_pic.PNG" src="../_images/Hedin_pic.PNG" /></p>
<p>The following code shows a step by step example to compute each of these quantities :</p>
<p>Let us start with computing <span class="math notranslate nohighlight">\(G_l^F\)</span> from the imaginary-frequency Green’s function we have obtained above. This will also be the starting point for every new iteration one might want to perform.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#Calculation of G_l_f using Least-Squares Fitting

G_l_f=matsf.fit(G_iw_f)

                
#G_tau,fermionic   

G_tau_f=tausf.evaluate(G_l_f)
</pre></div>
</div>
</div>
</div>
<p>The next step in order to perform a full iteration of GF2 &amp; GW is the evaluation of the basis representation <span class="math notranslate nohighlight">\(G_l^F\)</span> on the <span class="math notranslate nohighlight">\(\tau\)</span>-sampling points.  Contrary to before when we computed <span class="math notranslate nohighlight">\(G(\bar{\tau}_k^F)\)</span>, these sampling point will be the bosonic sampling points <span class="math notranslate nohighlight">\(\tau_k^B\)</span>. This allows us to switch to bosonic statistic and thus be able to calculate associated quantities like the Polarization <span class="math notranslate nohighlight">\(P\)</span>.[5]</p>
<div class="math notranslate nohighlight">
\[G(\bar{\tau}_k^B)= \sum_{l=0}^{L-1}G_l^F  U_l^F(\bar{\tau}_k^B)\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#G_tau, bosonic

G_tau_b=np.einsum(&#39;lt,l-&gt;t&#39;,basisf.u(tausb.tau),G_l_f)

#G_tau_b=tausb.evaluate(G_l_f)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.plot(tausb.tau,G_tau_b.real,label=&#39;real&#39;)
pl.plot(tausb.tau,G_tau_b.imag,label=&#39;imaginary&#39;)

pl.title(r&#39;$G(\tau)$&#39;)
pl.xlabel(r&#39;$\tau$&#39;)
pl.legend()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f22d7220730&gt;
</pre></div>
</div>
<img alt="../_images/GW_py_12_1.png" src="../_images/GW_py_12_1.png" />
</div>
</div>
<p>The so-called Polarization <span class="math notranslate nohighlight">\(P(\bar\tau_k^B)\)</span> is given by the random phase approximation, a connection between two Green’s functions:</p>
<div class="math notranslate nohighlight">
\[P(\bar{\tau}_k^B)=G(\bar{\tau}_k^B)*G(\beta-\bar{\tau}_k^B)\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#Polarisation P, bosonic

P_tau_b=G_tau_b*(basisf.u(beta-tausb.tau).T@G_l_f)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.plot(tausb.tau,P_tau_b.imag,label=&#39;imaginary&#39;)
pl.plot(tausb.tau,P_tau_b.real,label=&#39;real&#39;)

pl.title(r&#39; $P(\tau)$&#39;)
pl.xlabel(r&#39;$\tau$&#39;)
pl.legend()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f22d6ff6700&gt;
</pre></div>
</div>
<img alt="../_images/GW_py_15_1.png" src="../_images/GW_py_15_1.png" />
</div>
</div>
<p>The same way we transformed <span class="math notranslate nohighlight">\(\hat G^F(i\bar{\omega}_n^F)\)</span> into <span class="math notranslate nohighlight">\(G^B(\bar\tau_k^B)\)</span> we are now able to transform <span class="math notranslate nohighlight">\(P^B(\bar\tau_k^B)\)</span> into <span class="math notranslate nohighlight">\(\hat P^B(i\bar{\omega}_n^B)\)</span> again using least Square fitting and evaluating <span class="math notranslate nohighlight">\(P_l^B\)</span> on the given sampling points (Matsubara frequencies).</p>
<div class="math notranslate nohighlight">
\[P_l^B=\underset{P_l}{\arg\min}   \sum_{k}|P(\bar{{\tau}}_k^B)-\sum_{l=0}^{N-1}\hat{U}_l^B (\bar{\tau}_k^B)P_l|^2\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#P_l, bosonic


P_l_b=tausb.fit(P_tau_b)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.semilogy(np.abs(P_l_b),&#39;+-&#39;)
pl.title(&#39;$P_l^B$ over l &#39;)
pl.xticks(range(0,20))
pl.xlabel(&#39;l&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;l&#39;)
</pre></div>
</div>
<img alt="../_images/GW_py_19_1.png" src="../_images/GW_py_19_1.png" />
</div>
</div>
<div class="math notranslate nohighlight">
\[\hat{P}(i\bar{\omega}_k^B)= \sum_{l=0}^{N-1} P_l^B\hat{U}_l^B(i\bar{\omega}_n^B)\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#P_iw, bosonic

#P_iw_b=np.einsum(&#39;lv,l-&gt;v&#39;, basisb.uhat(matsb.wn),P_l_b)

P_iw_b=matsb.evaluate(P_l_b)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.plot(matsb.wn,P_iw_b.imag,label=&#39;imaginary&#39;)
pl.plot(matsb.wn,P_iw_b.real,label=&#39;real&#39;)
pl.title(r&#39;$P(i\omega)$&#39;)
pl.xlabel(r&#39;$\omega$&#39;)
pl.legend()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f22d6e86fd0&gt;
</pre></div>
</div>
<img alt="../_images/GW_py_22_1.png" src="../_images/GW_py_22_1.png" />
</div>
</div>
<p>Following <span class="math notranslate nohighlight">\(P\)</span> we will now calculate the Screened Interaction <span class="math notranslate nohighlight">\(W\)</span> with the following formula:</p>
<div class="math notranslate nohighlight">
\[\hat{{W}}(i\bar{\omega}_n^B)= U + U\hat{P}(i\bar{\omega}_n^B)\hat{{W}}(i\bar{\omega}_n^B)\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[\hat{{W}}(i\bar{\omega}_n^B)= \frac{U}{1-U\hat{P}(i\bar{\omega}_n^B)}\]</div>
<p>This equation has the exact same form as the Dyson equation but instead of connecting the Green’s functions and the self energy it connects the Screened Coulomb Interaction <span class="math notranslate nohighlight">\(W\)</span> and the polarization operator <span class="math notranslate nohighlight">\(P\)</span>. Because <span class="math notranslate nohighlight">\(U\)</span> is the bare Coulomb interaction and <span class="math notranslate nohighlight">\(P\)</span> is an object containing all irreducible processes (meaning in Feynmann diagrams cutting an interaction line U does not result in two sides) <span class="math notranslate nohighlight">\(W\)</span> can be understood as the sum of all possible Feymann diagrams with an interaction U between its two parts.[5][11] This becomes quite intuitive if we look at</p>
<div class="math notranslate nohighlight">
\[W= U + UPW= U+UP(U+UP(U+UP(...)))=U+UPU+...\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#W_iw, bosonic  

U=1/2

W_iw_b_U=U/(1-(U*P_iw_b))

W_iw_b=W_iw_b_U-U

#W_iw_b is the part depending on the frequency, any further calculations 
#will be done using this and not W_iw_b_U
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.plot(matsb.wn,W_iw_b.imag,label=&#39;imaginary&#39;)
pl.plot(matsb.wn,W_iw_b.real,label=&#39;real&#39;)
pl.title(r&#39;$W(i\omega)$&#39;)
pl.xlabel(r&#39;$\omega$&#39;)
pl.legend()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f22d6e09be0&gt;
</pre></div>
</div>
<img alt="../_images/GW_py_25_1.png" src="../_images/GW_py_25_1.png" />
</div>
</div>
<div class="math notranslate nohighlight">
\[W_l^B\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#W_l, bosonic

W_l_b=matsb.fit(W_iw_b)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.semilogy(np.abs(W_l_b),&#39;+-&#39;)
pl.title(&#39;$W_l^B$ over l &#39;)
pl.xticks(range(0,20))
pl.xlabel(&#39;l&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;l&#39;)
</pre></div>
</div>
<img alt="../_images/GW_py_28_1.png" src="../_images/GW_py_28_1.png" />
</div>
</div>
<p>In the next step we are changing back into fermionic statistics:</p>
<div class="math notranslate nohighlight">
\[{W}(\bar{\tau}_k^F)= \sum_{l=0}^{N-1} W_l ^BU_l^B(\bar{\tau}_k^F) \]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#W_tau_f, fermionic

W_tau_f=np.einsum(&#39;lt,l-&gt;t&#39;,basisb.u(tausf.tau),W_l_b)

#W_tau_f=tausf.evaluate(W_l_b)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.plot(tausf.tau,W_tau_f.imag,label=&#39;imaginary&#39;)
pl.plot(tausf.tau,W_tau_f.real,label=&#39;real&#39;)
pl.title(r&#39;$W(\tau)$&#39;)
pl.xlabel(r&#39;$\tau$&#39;)
pl.legend()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f22d6d12ca0&gt;
</pre></div>
</div>
<img alt="../_images/GW_py_31_1.png" src="../_images/GW_py_31_1.png" />
</div>
</div>
<p>After changing back into fermionic statistics the next quantity that is being dealt with is the so-called self energy <span class="math notranslate nohighlight">\(\Sigma\)</span>. When we first introduced the Dyson equation in the first chapter, we saw <span class="math notranslate nohighlight">\(V\)</span> as some sort of pertubation. The self-energy is very much alike as it describes the correlation effects of a many-body system. Here we will calculate <span class="math notranslate nohighlight">\(\tilde{\Sigma}(\bar{\tau}_k^F)\)</span> using <span class="math notranslate nohighlight">\(\Sigma^{GW}\)</span> so that</p>
<div class="math notranslate nohighlight">
\[{\Sigma}(\bar{\tau}_k^F)=-G(\bar{\tau}_k^F)*{W}(\bar{\tau}_k^F).\]</div>
<p>This can again be rewritten into its equivalent form</p>
<div class="math notranslate nohighlight">
\[\Sigma=-G(U+UP(U+UP(...)))= -(GU+GUPU+GUPUPU+...)\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#E_tau , fermionic   

E_tau_f=G_tau_f*W_tau_f
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.plot(tausf.tau,E_tau_f.imag,label=&#39;imaginary&#39;)
pl.plot(tausf.tau,E_tau_f.real,label=&#39;real&#39;)
pl.title(r&#39;$\Sigma(\tau)$&#39;)
pl.xlabel(r&#39;$\tau$&#39;)
pl.legend()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f22d6c21760&gt;
</pre></div>
</div>
<img alt="../_images/GW_py_34_1.png" src="../_images/GW_py_34_1.png" />
</div>
</div>
<div class="math notranslate nohighlight">
\[{\Sigma}_l^F\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#E_l, fermionic

E_l_f=tausf.fit(E_tau_f)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.semilogy(np.abs(E_l_f),&#39;+-&#39;)
pl.title(&#39;$\Sigma_l^F$ over l &#39;)
pl.xticks(range(0,20))
pl.xlabel(&#39;l&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;l&#39;)
</pre></div>
</div>
<img alt="../_images/GW_py_37_1.png" src="../_images/GW_py_37_1.png" />
</div>
</div>
<p>We will calculate</p>
<div class="math notranslate nohighlight">
\[\hat{\Sigma}(i\bar{\omega}_n^F)=-UG(\beta)+\sum_{l=0}^{N-1}{\Sigma}_l^F \hat{U}_l^F(i\bar{\omega}_n^F)\]</div>
<p>with <span class="math notranslate nohighlight">\(UG(\beta)\)</span> as the so called Hartee Fock term.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#E_iw, fermionic

#E_iw_f=p.einsum(&#39;lw,l-&gt;w&#39;,basisf.uhat(matsf.wn),E_l_f)-U*(basisf.u(beta).T@G_l_f)

E_iw_f_U=matsf.evaluate(E_l_f)-U*(basisf.u(beta).T@G_l_f)
E_iw_f=matsf.evaluate(E_l_f)


#store E_iw_f of this iteration in E_iw_f_arr
E_iw_f_arr.append(E_iw_f_U)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = pl.subplots(1,2, figsize=(12,5) )
ax[0].plot(matsf.wn,E_iw_f_U.imag)
ax[0].set_title(&#39;Imaginary part of $\Sigma(i\omega)$&#39;)
ax[0].set_xlabel(r&#39;$\omega$&#39;)
ax[1].plot(matsf.wn,E_iw_f_U.real)
ax[1].set_title(&#39;Real part of $\Sigma(i\omega)$&#39;)
ax[1].set_xlabel(r&#39;$\omega$&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;$\\omega$&#39;)
</pre></div>
</div>
<img alt="../_images/GW_py_40_1.png" src="../_images/GW_py_40_1.png" />
</div>
</div>
<p>Last but not least we will obtain <span class="math notranslate nohighlight">\(G^F(i\bar{\omega}_n^F)\)</span> through the Dyson Equation of GW:</p>
<div class="math notranslate nohighlight">
\[\hat{G}(i\bar{\omega}_k^F)=G_0(i\bar{\omega}_k^F)+G_0(i\bar{\omega}_k^F)\hat{\Sigma}(i\bar{\omega}_n^F)\hat{G}(i\bar{\omega}_k^F)\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[\hat{G}(i\bar{\omega}_k^F)=\frac{1}{G_0(i\bar{\omega}_k^F)^{-1}-\hat{\Sigma}(i\bar{\omega}_n^F)}\]</div>
<p>We have now calculated the full Green’s function of the system with <span class="math notranslate nohighlight">\(\Sigma\)</span> as a set of (one-particle) irreducible processes connected by <span class="math notranslate nohighlight">\(G_0\)</span>.[11]</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#G_iw, fermonic     -&gt; Dyson Equation

G_iw_f=((G_iw_0)**-1-E_iw_f)**-1    
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pl.plot(matsf.wn,G_iw_f.imag,label=&#39;imaginary&#39;)
pl.plot(matsf.wn,G_iw_f.real,label=&#39;real&#39;)
pl.title(r&#39;$G(i\omega)$&#39;)
pl.xlabel(r&#39;$\omega$&#39;)
pl.legend()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7f22d6dcfa00&gt;
</pre></div>
</div>
<img alt="../_images/GW_py_43_1.png" src="../_images/GW_py_43_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>if (i&gt;0):
    pl.plot(matsf.wn,E_iw_f_arr[i].imag,label=&#39;current&#39;)
    pl.title(r&#39;$\Sigma(i\omega)$ in the current and previous iteration&#39;)
    pl.plot(matsf.wn,E_iw_f_arr[i-1].imag,&#39;.&#39;,label=&#39;previous&#39;)
    pl.legend()
    pl.show()
    pl.plot(matsf.wn,np.abs(E_iw_f_arr[i]-E_iw_f_arr[i-1]))
    pl.title(r&#39;$|\Sigma_i(i\omega)-\Sigma_{i-1}(i\omega)|$&#39; )
    
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#Iterations 
i+=1
print(&#39;full iterations: &#39;,i)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>full iterations:  1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(G_iw_f)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 2.07806360e-18+0.03657118j  3.31916878e-19+0.10932936j
 -8.59280574e-18+0.18513256j  5.47680338e-18+0.24022776j
 -4.50903710e-18+0.28186922j  2.10892056e-17+0.34036864j
  6.10886753e-18+0.4278915j   2.25032005e-18+0.57065346j
 -1.69861463e-17+0.83239627j  9.05172560e-17+1.38269615j
  7.62400416e-17-1.38269615j -1.54955306e-17-0.83239627j
  5.43243553e-18-0.57065346j  6.63080433e-18-0.4278915j
  2.09349407e-17-0.34036864j -4.54682983e-18-0.28186922j
  5.31668120e-18-0.24022776j -8.62614007e-18-0.18513256j
  3.05041330e-19-0.10932936j  2.05045978e-18-0.03657118j]
</pre></div>
</div>
</div>
</div>
<p>With this we have completed one full iteration of GF2 &amp; GW. Repeating this over and over again will show convergence and thus give the desired approximation to the self-energy.</p>
</section>
<section id="conclusion">
<h1>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">#</a></h1>
<p>The above code illustrated a full iteration of GW &amp; GF2 with sparse_ir.</p>
<p>Taking advantage of the Singular Value Expansion of the imaginary time Green’s function allowed for the construction of the Intermediate Representation: A basis for the Matsubara Green’s function which makes it possible to switch back and forth between time and frequency domain.</p>
<p>Pairing this with the GW &amp; GF2 approximations and the Hedin equations, we were able to make use of the IR. Because the Hedin equations are diagonal in one or the other representation, we had the IR basis work as a translator between these and ensure excact as well as fast calcuations for quantities like the self-energy, the polarization and the screened colomb interaction. All this while suffering a minimal loss in information.</p>
<p>Each quantity was computed after the same scheme: Calculation, transformation and Evaluation. First we derived the quantity in its time or frequency representation through a Hedin equation. Then we transformed it using Least Square fitting. Once we obtained the IR expansion coefficients we were able to evaluate the function on the corresponding sampling points given by sparse_ir.</p>
<p>Of course, in order to increase the accuracy of our calculations more iterations will be needed.</p>
<p>Naturally this idea of using the Intermediate Representation in order to facilitate calculations can be expanded in various directions. One could go beyond single orbital calculations with the use of matrices or implement another type of vertex-approximation. Undoubtedly not anywhere near all options have been exhausted, not for the use of the IR Basis nor other machine learning methods used in physics.</p>
</section>
<section id="sources">
<h1>Sources<a class="headerlink" href="#sources" title="Permalink to this headline">#</a></h1>
<p>[1] H.Bruus, Karsten Flensberg,<em>Many-body Quantum Theory in Condensed    Matter  Physics</em> (Oxford University Press Inc., New York, 2004)<br>
[2] J.W.Negele, H.Orland, <em>Quantum Many-Particle Systems</em> (Westview Press, 1998)<br>
[3] G.D.Mahan,<em>Many-Particle Physics</em> (Kluwer Academic/Plenum Publishers, New York, 2000)<br>
[4] P.C.Hansen,<em>Dicrete Inverse Problems</em>(Society for Industrial and Applied Mathematics, Philadelphia,2010)<br>
[5] <a class="reference external" href="http://J.Li">J.Li</a>, M.Wallerberger, N.Chikano, C.Yeh, E.Gull and H.Shinaoka, Sparse sampling approach to efficient ab initio calculations at finite temperature, Phys. Rev. B 101, 035144 (2020)<br>
[6] M.Wallerberger, H. Shinaoka, A.Kauch, Solving the Bethe–Salpeter equation with exponential convergence, Phys. Rev. Research 3, 033168 (2021)<br>
[7] H. Shinaoka, N. Chikano, E. Gull, J. Li, T. Nomoto, J. Otsuki, M. Wallerberger, T. Wang, K. Yoshimi, Efficient ab initio many-body calculations based on sparse modeling of Matsubara Green’s function (2021)<br>
[8] F. Aryasetiawan and O. Gunnarsson, The GW method, Rep. Prog. Phys. 61 (1998) 237<br>
[9] Matteo Gatti, <em>The GW approximation</em>, TDDFT school, Benasque (2014)<br>
[10] C.Friedrich, <em>Many-Body Pertubation Theory;The GW approximation</em>, Peter Grünberg Institut and Institute for Advanced Simulation, Jülich <br>
[11] K. Held, C. Taranto, G. Rohringer, and A. Toschi, <em>Hedin Equations, GW, GW+DMFT, and All That</em> (Modeling and Simulation Vol. 1, Forschungszentrum Jülich, 2011)<br>
[12] X. Gonze, B. Amadon, P.-M. Anglade, J.-M. Beuken, F. Bottin, P. Boulanger,
F. Bruneval, D. Caliste, R. Caracas, M. Côté, T. Deutsch, L. Genovese, Ph. Ghosez,M. Giantomassi, S. Goedecker, D.R. Hamann, P. Hermet, F. Jollet, G. Jomard, S. Leroux, M. Mancini, S. Mazevet, M.J.T. Oliveira, G. Onida, Y. Pouillon, T. Rangel,G.-M. Rignanese, D. Sangalli, R. Shaltaf, M. Torrent, M.J. Verstraete, G. Zerah, J.W. Zwanziger, <em>ABINIT: First-principles approach to material and nanosystem properties</em>, Computer Physics Communications 180 (2009) 2582–2615<br>
[13] H. Shinaoka, J. Otsuki, M. Ohzeki and K. Yoshimi, Compressing Green’s function using
intermediate representation between imaginary-time and real-frequency domains, Physical
Review B 96(3), 035147 (2017), doi:10.1103/physrevb.96.035147.<br>
[14] J. Otsuki, M. Ohzeki, H. Shinaoka and K. Yoshimi, Sparse modeling approach to analytical continuation of imaginary-time quantum Monte Carlo data, Physical Review E
95(6), 061302® (2017), doi:10.1103/physreve.95.061302.<br></p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./src"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="second_order_perturbation_py.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Second-order perturbation</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="DMFT_IPT_py.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">DMFT with IPT solver</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By sparse-ir developers<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>